#!/usr/bin/python3

import os
import json
import nibabel as nib
import matplotlib.pyplot as plt

###################################### Define Fucntions #####################################

def prepare_mprage(subject_id, path_to_mprage, centre_of_gravity_x, centre_of_gravity_y, centre_of_gravity_z, extraction_threshold, output_folder):
    
    # This script prepares the MPRAGE image(s) for the analysis. Pipeline:  
        # 1 - Bias correcting each MPRAGE images
        # 2 - Registering MPRAGES if there is more than one
        # 3 - Averaging the registered and target MPRAGE if there is more than one
        # 4 - Skull stripping the MPRAGE
        # 5 - x-y flipping the skull stripped MPRAGE
    
    # Create the output folder
    preprocessed_mprage_folder = os.path.join(output_folder, subject_id + '_preprocessed_mprage')
    if not os.path.exists(preprocessed_mprage_folder):
        os.system('mkdir %s' % preprocessed_mprage_folder)
        
    # Find MPRAGE images
    mprage_images = os.listdir(path_to_mprage)
    
    # Biascorrection 
    for i in mprage_images:
        call = "/usr/local/ANTs/bin/N4BiasFieldCorrection -d 3 -i %s -o %s -v" % (os.path.join(path_to_mprage, i),
                                                                                  os.path.join(path_to_mprage, i))
        os.system(call)
    
    # Register MPRAGEs if there are two of them 
    if len(mprage_images) > 1: 
        first_mprage = mprage_images[0]
        second_mprage = mprage_images[1]
       
        register_call = 'export ANTSPATH=/usr/local/ANTs/bin/;export PATH=${ANTSPATH}:$PATH;/usr/local/ANTs/bin/antsRegistrationSyN.sh -d 3 -f %s -m %s -o %s -t r -n 6' % (os.path.join(path_to_mprage, second_mprage),
                                                                                                                                                                            os.path.join(path_to_mprage, first_mprage),
                                                                                                                                                                            os.path.join(preprocessed_mprage_folder, subject_id + '_registered'))
        os.system(register_call)
        registered_image = os.path.join(preprocessed_mprage_folder, subject_id + '_registeredWarped.nii.gz')
         
        # Average the registered MPRAGE with the target
        average_call = '/usr/local/ANTs/bin/AverageImages 3 %s 1 %s %s' % (os.path.join(preprocessed_mprage_folder, subject_id + '_averaged_mprages.nii.gz'),
                                                                           os.path.join(path_to_mprage, second_mprage),
                                                                           registered_image)
        os.system(average_call)
        averaged_mprage = os.path.join(preprocessed_mprage_folder, subject_id + '_averaged_mprages.nii.gz')
   
    else:
        averaged_mprage = os.path.join(mprage_images[0])        
       
    # Brain extraction mask (created by fsl BET)
    extracted_mprage = os.path.join(preprocessed_mprage_folder, subject_id + '_brain_averaged_mprages.nii.gz')
    extracted_mask = os.path.join(preprocessed_mprage_folder, subject_id + '_brain_averaged_mprages_mask.nii.gz')
    call = 'FSLDIR=/usr/local/fsl;. ${FSLDIR}/etc/fslconf/fsl.sh;PATH=${FSLDIR}/bin:${PATH};export FSLDIR PATH;/usr/local/fsl/bin/bet %s %s -f %s -c %s %s %s -m' % (averaged_mprage, extracted_mprage,
                                                                                                                                                                     extraction_threshold,
                                                                                                                                                                     centre_of_gravity_x,
                                                                                                                                                                     centre_of_gravity_y, 
                                                                                                                                                                     centre_of_gravity_z)
    os.system(call)
    
        
    # Brain extraction segmentation (altAnts)
    call2 = 'export ANTSPATH=/usr/local/ANTs/bin/;export PATH=${ANTSPATH}:$PATH;/usr/local/ANTs/bin/brainExtractionSegmentation.pl --input %s --initial-brain-mask %s --bias-correct 0 --output-root %s' % (averaged_mprage,
                                                                                                                     extracted_mask,
                                                                                                                     os.path.join(preprocessed_mprage_folder, subject_id + '_final')) 
    os.system(call2)
    extracted_brain = os.path.join(preprocessed_mprage_folder, subject_id + '_finalExtractedBrain.nii.gz')

    return (preprocessed_mprage_folder, averaged_mprage, extracted_brain)    
#     #Flip the averaged and skull stripped mprage
#    flipped_extracted_brain = os.path.join(preprocessed_mprage_folder, 'flipped_finalExtractedBrain.nii.gz')
#    flip_call = 'FSLDIR=/usr/local/fsl;. ${FSLDIR}/etc/fslconf/fsl.sh;PATH=${FSLDIR}/bin:${PATH};export FSLDIR PATH;/usr/local/fsl/bin/fslswapdim %s x -y z %s' % (extracted_mprage, flipped_extracted_brain)
#    os.system(flip_call)
    
#    return (preprocessed_mprage_folder, averaged_mprage, extracted_brain, flipped_extracted_brain)


def warp_to_invivo(subject_id, mprage_image, template_path, output_folder, num_threads): 
    
    # This function is a wrapper around ANTs SyN registration. 
        
    # Warp to Template (use 5 threads change -n flag in warp_call if you want more threads)

    warp_results_folder = os.path.join(output_folder, subject_id + '_reg_avgmprage2atlas')
    if not os.path.exists(warp_results_folder):
        os.system('mkdir %s' % warp_results_folder)
    
    warp_call = 'export ANTSPATH=/usr/local/ANTs/bin/;export PATH=${ANTSPATH}:$PATH;/usr/local/ANTs/bin/antsRegistrationSyN.sh -d 3 -f %s -m %s -o %s -n %s' % (template_path, mprage_image, os.path.join(warp_results_folder, subject_id + '_'),str(num_threads))
    os.system(warp_call)
    warped_mprage = os.path.join(warp_results_folder, subject_id + '_Warped.nii.gz')
    generic_affine = os.path.join(warp_results_folder, subject_id + '_0GenericAffine.mat')
    
    return (warp_results_folder, warped_mprage, generic_affine)

def make_plot(subject_id, base_image, overlay, title, filename, x, y, z, output_folder):
    
    # This function simply gets two MRI images as inputs and overlays them 
    #using different colors for each image. Used as a diagnostic method.
    
    diagnostic_images = os.path.join(output_folder, 'diagnostic_images')
    if not os.path.exists(diagnostic_images):
        os.system('mkdir %s' % diagnostic_images)
        
    fig, (ax1, ax2, ax3) = plt.subplots(1,3)
    fig.suptitle(title, fontsize=20)

    epi_img = nib.load(base_image)
    epi_img_data = epi_img.get_fdata()
    ax1.imshow(epi_img_data[x,:,:], cmap="gray")
    ax2.imshow(epi_img_data[:,y,:], cmap="gray")
    ax3.imshow(epi_img_data[:,:,z], cmap="gray")
    ax1.axis('off')
    ax2.axis('off')
    ax3.axis('off')  
    
    if overlay != 'NA':
        epi_img = nib.load(overlay)
        epi_img_data = epi_img.get_fdata()
        ax1.imshow(epi_img_data[x,:,:], cmap="hot", alpha=0.4)
        ax2.imshow(epi_img_data[:,y,:], cmap="hot", alpha=0.4)
        ax3.imshow(epi_img_data[:,:,z], cmap="hot", alpha=0.4)
        ax1.axis('off')
        ax2.axis('off')
        ax3.axis('off')

    plt.savefig(os.path.join(diagnostic_images, subject_id + '_' + filename))    
    
    return(diagnostic_images)


###################### Define the Paths and parameters ###########################

# os.system('cat /proc/cpuinfo')

# Flywheel path
flywheel_base ='/flywheel/v0/'

# Path to input folder 
MPRAGE_01_folder = os.path.join(flywheel_base, 'input/MPRAGE_01')
MPRAGE_02_folder = os.path.join(flywheel_base, 'input/MPRAGE_02')
Template_folder = os.path.join(flywheel_base, 'input/Template')

# Set path to required inputs
MPRAGE_01 = os.path.join(MPRAGE_01_folder, os.listdir(MPRAGE_01_folder)[0])
MPRAGE_02 = os.path.join(MPRAGE_02_folder, os.listdir(MPRAGE_02_folder)[0])
if os.path.isdir(Template_folder):
    Template = os.path.join(Template_folder, os.listdir(Template_folder)[0])
else:
    Template = '/opt/invivoTemplate.nii.gz'

# Set other paths
manifest_file = os.path.join(flywheel_base, 'manifest.json')
config_path = os.path.join(flywheel_base, 'config.json')

first_output_dir = '/firstOutput'
final_output_dir = os.path.join(flywheel_base, 'output')
os.system('mkdir %s'%first_output_dir)

T1folder = os.path.join(first_output_dir, 'T1')
os.system('mkdir %s' % T1folder)
os.system('cp %s %s' % (MPRAGE_01, T1folder))
os.system('cp %s %s' % (MPRAGE_02, T1folder))

###################Parse Config Here############################

with open(config_path) as config_file:
    job_config = json.load(config_file)
config = job_config['config']

centre_of_gravity_x = config['centre_of_gravity_x']
centre_of_gravity_y = config['centre_of_gravity_y']
centre_of_gravity_z = config['centre_of_gravity_z']
subject_id = config['subject_id']
extraction_threshold = config['extraction_threshold']
number_of_threads = config['number_of_threads']

###################Run Algorithm################################
   
# Bias corrects mprage images, registers, averages (normalized), skull strips and flips
preprocessed_mprage_folder, averaged_mprage, extracted_brain = prepare_mprage(subject_id, T1folder, centre_of_gravity_x, centre_of_gravity_y, centre_of_gravity_z, extraction_threshold, first_output_dir)

# Plot averaged structural
make_plot(subject_id, averaged_mprage, 'NA', 'MPRAGE Average', 'averaged_mprage.png', centre_of_gravity_x, centre_of_gravity_y, centre_of_gravity_z, first_output_dir)
   
# Saves a brain extraction diagnostic image
make_plot(subject_id, averaged_mprage, extracted_brain, 'Brain Extraction Results', 'brain_extraction_qa.png', centre_of_gravity_x, centre_of_gravity_y, centre_of_gravity_z, first_output_dir)
    
# Warps the averaged mprage to the template 
warp_results_folder, warped_mprage, standard_generic = warp_to_invivo(subject_id, extracted_brain, Template, first_output_dir, number_of_threads)
    
# Saves some more diagnostic images for registrations
make_plot(subject_id, Template, warped_mprage, 'Warp results', 'mprage2template_qa.png', 131, 105, 45, first_output_dir)

################## Zip everything and output ##################################

# Move mat, pdf and png files to the final output folder
os.system('cd %s; mv %s %s/' % (os.path.join(first_output_dir, 'diagnostic_images'), '*.png', final_output_dir)) 
os.system('cd %s; rm -r %s' % (first_output_dir, 'diagnostic_images'))

# Zip and move the maps
os.system('cd %s; zip -q -r %s *'%(first_output_dir, os.path.join(final_output_dir, subject_id + '_preprocessed.zip')))
