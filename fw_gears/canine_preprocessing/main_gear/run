#!/usr/bin/python3

import os
import json
import nibabel as nib
import matplotlib.pyplot as plt

os.system('/usr/local/fsl/bin/bet')
###################################### Define Fucntions #####################################

def prepare_mprage(path_to_mprage, centre_of_gravity, extraction_threshold, output_folder):
    
    # This script prepares the MPRAGE image(s) for the analysis. Pipeline:  
        # 1 - Bias correcting each MPRAGE images
        # 2 - Registering MPRAGES if there is more than one
        # 3 - Averaging the registered and target MPRAGE if there is more than one
        # 4 - Skull stripping the MPRAGE
        # 5 - x-y flipping the skull stripped MPRAGE
    
    # Find MPRAGE images
    mprage_images = os.listdir(path_to_mprage)
    
    # Biascorrection 
    for i in mprage_images:
        call = "/usr/local/ANTs/bin/N4BiasFieldCorrection -d 3 -i %s -o %s -v" % (os.path.join(path_to_mprage, i),
                                                              os.path.join(path_to_mprage, i))
        os.system(call)
    
    # Register MPRAGEs if there are two of them 
    preprocessed_mprage_folder = os.path.join(output_folder, 'preprocessed_mprage')
    if not os.path.exists(preprocessed_mprage_folder):
        os.system('mkdir %s' % preprocessed_mprage_folder)
        
    if len(mprage_images) > 1: 
        first_mprage = mprage_images[0]
        second_mprage = mprage_images[1]
        print('REGISTERING MPRAGE IMAGES')    
        
        register_call = 'export ANTSPATH=/usr/local/ANTs/bin/;export PATH=${ANTSPATH}:$PATH;/usr/local/ANTs/bin/antsRegistrationSyN.sh -d 3 -f %s -m %s -o %s -t r -n 6' % (os.path.join(path_to_mprage, second_mprage),
                                                                                     os.path.join(path_to_mprage, first_mprage),
                                                                                     os.path.join(preprocessed_mprage_folder, 'registered'))
        os.system(register_call)
        registered_image = os.path.join(preprocessed_mprage_folder, 'registeredWarped.nii.gz')
         
        # Average the registered MPRAGE with the target
        print('AVERAGING MPRAGE IMAGES')
        average_call = '/usr/local/ANTs/bin/AverageImages 3 %s 1 %s %s' % (os.path.join(preprocessed_mprage_folder, 'averaged_mprages.nii.gz'),
                                                       os.path.join(path_to_mprage, second_mprage),
                                                       registered_image)
        os.system(average_call)
        averaged_mprage = os.path.join(preprocessed_mprage_folder, 'averaged_mprages.nii.gz')
       
        # Brain extraction mask (created by fsl BET)
        print('PERFORMING A BRAIN EXTRACTION')
        extracted_mprage = os.path.join(preprocessed_mprage_folder, 'brain_averaged_mprages.nii.gz')
        extracted_mask = os.path.join(preprocessed_mprage_folder, 'brain_averaged_mprages_mask.nii.gz')
        call = 'FSLDIR=/usr/local/fsl;. ${FSLDIR}/etc/fslconf/fsl.sh;PATH=${FSLDIR}/bin:${PATH};export FSLDIR PATH;/usr/local/fsl/bin/bet %s %s -f %s -c %s %s %s -m' % (averaged_mprage, extracted_mprage,
                                                    extraction_threshold,
                                                    centre_of_gravity[0],
                                                    centre_of_gravity[1], 
                                                    centre_of_gravity[2])
        os.system(call)
    
    else:
        averaged_mprage = os.path.join(mprage_images[0]) 
        
    # Brain extraction segmentation (altAnts)
    print('PERFORMING SEGMENTATION FOR THE BRAIN EXTRACTION')    
    call2 = 'export ANTSPATH=/usr/local/ANTs/bin/;export PATH=${ANTSPATH}:$PATH;/usr/local/ANTs/bin/brainExtractionSegmentation.pl --input %s --initial-brain-mask %s --bias-correct 0 --output-root %s' % (averaged_mprage,
                                                                                                                     extracted_mask,
                                                                                                                     os.path.join(preprocessed_mprage_folder, 'final')) 
    os.system(call2)
    extracted_brain = os.path.join(preprocessed_mprage_folder, 'finalExtractedBrain.nii.gz')
    
    # Flip the averaged and skull stripped mprage
    print('FLIPPING THE IMAGE')
    flipped_extracted_brain = os.path.join(preprocessed_mprage_folder, 'flipped_finalExtractedBrain.nii.gz')
    flip_call = 'FSLDIR=/usr/local/fsl;. ${FSLDIR}/etc/fslconf/fsl.sh;PATH=${FSLDIR}/bin:${PATH};export FSLDIR PATH;/usr/local/fsl/bin/fslswapdim %s x -y z %s' % (extracted_mprage, flipped_extracted_brain)
    os.system(flip_call)
    
    return (preprocessed_mprage_folder, averaged_mprage, extracted_brain, flipped_extracted_brain)

def warp_to_invivo(mprage_image, template_path, output_folder, num_threads, convention): 
    
    # This function is a wrapper around ANTs SyN registration. 
        
    # Warp to Template (use 5 threads change -n flag in warp_call if you want more threads)
    print('WARPING THE AVERAGED MPRAGE TO INVIVO ATLAS')
    warp_results_folder = os.path.join(output_folder, 'reg_avgmprage2atlas')
    if not os.path.exists(warp_results_folder):
        os.system('mkdir %s' % warp_results_folder)
    
    warp_call = 'export ANTSPATH=/usr/local/ANTs/bin/;export PATH=${ANTSPATH}:$PATH;/usr/local/ANTs/bin/antsRegistrationSyNQuick.sh -d 3 -f %s -m %s -o %s -n %s' % (template_path, mprage_image, os.path.join(warp_results_folder, convention),str(num_threads))
    os.system(warp_call)
    warped_mprage = os.path.join(warp_results_folder, convention + 'Warped.nii.gz')
    generic_affine = os.path.join(warp_results_folder, convention + '0GenericAffine.mat')
    
    return (warp_results_folder, warped_mprage, generic_affine)

def make_overlay_plot(base_image, overlay, title, filename, x, y, z, output_folder):
    
    # This function simply gets two MRI images as inputs and overlays them 
    #using different colors for each image. Used as a diagnostic method.
    
    diagnostic_images = os.path.join(output_folder, 'diagnostic_images')
    if not os.path.exists(diagnostic_images):
        os.system('mkdir %s' % diagnostic_images)
        
    fig, (ax1, ax2, ax3) = plt.subplots(1,3)
    fig.suptitle(title, fontsize=20)

    epi_img = nib.load(base_image)
    epi_img_data = epi_img.get_fdata()
    ax1.imshow(epi_img_data[x,:,:], cmap="gray")
    ax2.imshow(epi_img_data[:,y,:], cmap="gray")
    ax3.imshow(epi_img_data[:,:,z], cmap="gray")
    
    epi_img = nib.load(overlay)
    epi_img_data = epi_img.get_fdata()
    ax1.imshow(epi_img_data[x,:,:], cmap="hot", alpha=0.4)
    ax2.imshow(epi_img_data[:,y,:], cmap="hot", alpha=0.4)
    ax3.imshow(epi_img_data[:,:,z], cmap="hot", alpha=0.4)

    plt.savefig(os.path.join(diagnostic_images, filename))    
    
    return(diagnostic_images)


###################### Define the Paths and parameters ###########################

# os.system('cat /proc/cpuinfo')

# Flywheel path
flywheel_base ='/flywheel/v0/'

# Path to input folder 
MPRAGE_01_folder = os.path.join(flywheel_base, 'input/MPRAGE_01')
MPRAGE_02_folder = os.path.join(flywheel_base, 'input/MPRAGE_02')
Template_folder = os.path.join(flywheel_base, 'input/Template')

# Set path to required inputs
MPRAGE_01 = os.path.join(MPRAGE_01_folder, os.listdir(MPRAGE_01_folder)[0])
MPRAGE_02 = os.path.join(MPRAGE_02_folder, os.listdir(MPRAGE_02_folder)[0])
Template = os.path.join(Template_folder, os.listdir(Template_folder)[0])

# Set other paths
manifest_file = os.path.join(flywheel_base, 'manifest.json')
config_path = os.path.join(flywheel_base, 'config.json')

first_output_dir = '/firstOutput'
final_output_dir = os.path.join(flywheel_base, 'output')
os.system('mkdir %s'%first_output_dir)

T1folder = os.path.join(first_output_dir, 'T1')
os.system('mkdir %s' % T1folder)
os.system('cp %s %s' % (MPRAGE_01, T1folder))
os.system('cp %s %s' % (MPRAGE_02, T1folder))

###################Parse Config Here############################

with open(config_path) as config_file:
    job_config = json.load(config_file)
config = job_config['config']

centre_of_gravity_x = config['centre_of_gravity_x']
centre_of_gravity_y = config['centre_of_gravity_y']
centre_of_gravity_z = config['centre_of_gravity_z']
extraction_threshold = config['extraction_threshold']
number_of_threads = config['number_of_threads']

###################Run Algorithm################################
    
# Assemble centre of gravity        
centre_of_gravity = [centre_of_gravity_x, centre_of_gravity_y, centre_of_gravity_z]
   
# Bias corrects mprage images, registers, averages (normalized), skull strips and flips
preprocessed_mprage_folder, averaged_mprage, extracted_brain, flipped_extracted_brain = prepare_mprage(T1folder, centre_of_gravity, extraction_threshold, first_output_dir)
    
# Saves a brain extraction diagnostic image
make_overlay_plot(averaged_mprage, extracted_brain, 'Brain Extraction Results', 'brain_extraction_qa.png', centre_of_gravity_x, centre_of_gravity_y, centre_of_gravity_z, first_output_dir)
    
# Warps the averaged mprage to the template 
warp_results_folder, warped_mprage, standard_generic = warp_to_invivo(extracted_brain, Template, first_output_dir, number_of_threads, 'dog_diff')
    
# Saves some more diagnostic images for standard and flipped registrations
make_overlay_plot(Template, warped_mprage, 'Warp results', 'mprage2template_qa.png', centre_of_gravity_x, centre_of_gravity_y, centre_of_gravity_z, first_output_dir)

################## Zip everything and output ##################################

# Move mat, pdf and png files to the final output folder
os.system('cd %s; mv %s %s/'%(os.path.join(first_output_dir, 'diagnostic_images'), '*.png', final_output_dir)) 

# Zip and move the maps
os.system('cd %s; zip -q -r %s *'%(first_output_dir, os.path.join(final_output_dir,'preprocessed.zip')))
