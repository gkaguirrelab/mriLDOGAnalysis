# #!/usr/local/bin/python3.7

import os
import imageio
import json
import nibabel as nib
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

###################################### Define Functions #####################################

def topup(subject_id, total_readout_time_AP, total_readout_time_PA, path_to_recon_fmris_folder, path_to_epi_image, output_folder):
    
    # Get the readout time of AP and PA and create a text file including those
    direction_vector_AP = '0 -1 0 %s\n' % str(total_readout_time_AP)
    direction_vector_PA = '0 1 0 %s' % str(total_readout_time_PA)
    acparam_file = os.path.join(path_to_recon_fmris_folder, subject_id + '_acqparams.txt')
    os.system('touch %s' % acparam_file)
    textfile = open(acparam_file, 'w')
    textfile.write(direction_vector_AP)
    textfile.write(direction_vector_PA)
    textfile.close()
    
    # Find the AP and PA images automatically from the headers so that we don't make a mistake
    for i in os.listdir(path_to_recon_fmris_folder):
        if i[-2:] == 'gz' or i[-6:] == 'gz':
            if '1' in os.popen('PrintHeader %s | grep descrip | grep phase |  cut -d \';\' -f 3 | cut -d \'=\' -f 2' % os.path.join(path_to_recon_fmris_folder,i)).read():
                ap_image = os.path.join(path_to_recon_fmris_folder, i)
            if '0' in os.popen('PrintHeader %s | grep descrip | grep phase |  cut -d \';\' -f 3 | cut -d \'=\' -f 2' % os.path.join(path_to_recon_fmris_folder,i)).read():
                pa_image = os.path.join(path_to_recon_fmris_folder, i)

    # Merge AP and PA singe-rep images into one for topup
    top_up_folder = os.path.join(output_folder, subject_id + '_top_up_files')
    if not os.path.exists(top_up_folder):
        os.system('mkdir %s' % top_up_folder)
    os.system('fslmerge -a %s %s %s' % (os.path.join(top_up_folder, subject_id + '_AP+PA'), ap_image, pa_image))
    
    # Calculate the b0 field
    os.system('topup --imain=%s --datain=%s '
              '--config=b02b0.cnf --out=%s --iout=%s --fout=%s' % (os.path.join(top_up_folder, subject_id + '_AP+PA.nii.gz'),
                                                                   acparam_file,
                                                                   os.path.join(top_up_folder, subject_id + '_topup_results'),
                                                                   os.path.join(top_up_folder, subject_id + '_b0_unwarped'),
                                                                   os.path.join(top_up_folder, subject_id + '_fieldmap_Hz')))

    # Apply correction to the EPI image(s)    
    raw_image_name = os.path.split(path_to_epi_image)[1]
    bias_corrected_epi_folder = os.path.join(output_folder, 'step1_' + subject_id + '_topup_corrected_epi')
    if not os.path.exists(bias_corrected_epi_folder):
        os.system('mkdir %s' % bias_corrected_epi_folder)
    bias_corrected_epi = os.path.join(bias_corrected_epi_folder, 'biasCorrected_' + raw_image_name)

    if int(os.popen('PrintHeader %s | grep descrip | grep phase |  cut -d \';\' -f 3 | cut -d \'=\' -f 2' % path_to_epi_image).read()) == 1:
        os.system('applytopup --imain=%s --inindex=1 --method=jac --datain=%s --topup=%s --out=%s' % (path_to_epi_image,
                                                                                                      acparam_file,
                                                                                                      os.path.join(top_up_folder, subject_id + '_topup_results'),
                                                                                                      bias_corrected_epi))
    elif int(os.popen('PrintHeader %s | grep descrip | grep phase |  cut -d \';\' -f 3 | cut -d \'=\' -f 2' % path_to_epi_image).read()) == 0:
        os.system('applytopup --imain=%s --inindex=2 --method=jac --datain=%s --topup=%s --out=%s' % (path_to_epi_image,
                                                                                                      acparam_file,
                                                                                                      os.path.join(top_up_folder, subject_id + '_topup_results'),
                                                                                                      bias_corrected_epi))
    else:
        raise ValueError('Your time series image is neither in AP nor in PA direction')
    
    # Create a target topuped image for the motion correction
    os.system('applytopup --imain=%s --inindex=1 --method=jac --datain=%s --topup=%s --out=%s' % (ap_image,
                                                                                                  acparam_file,
                                                                                                  os.path.join(top_up_folder, subject_id + '_topup_results'),
                                                                                                  os.path.join(top_up_folder, subject_id + '_moco_target')))
    return (raw_image_name, top_up_folder, bias_corrected_epi)

def moco(subject_id, raw_image_name, bias_corrected_epi, top_up_folder, output_folder): 
    
    # This function does motion correction and calculates time derivatives of
    # the output motion covariates
    
    # Folder for the output 
    mocod_folder = os.path.join(output_folder, 'step2_' + subject_id + '_motion_corrected_epi')
    if not os.path.exists(mocod_folder):
        os.system('mkdir %s' % mocod_folder)
    
    # Motion Correction
    motion_corrected_epi = os.path.join(mocod_folder, 'motionCorrected_' + raw_image_name)
    mc_to_this = os.path.join(top_up_folder, subject_id + '_moco_target.nii.gz')
    mcflirt_call = 'mcflirt -in %s -o %s -reffile %s -dof 6 -plots' % (bias_corrected_epi,
                                                                        motion_corrected_epi,
                                                                        mc_to_this)
    os.system(mcflirt_call)

    # Move motion covariates to their own folder
    moco_cov = os.path.join(output_folder, subject_id + '_moco_covariates')
    if not os.path.exists(moco_cov):
        os.system('mkdir %s' % moco_cov)    
    os.system('mv %s/*.par %s/%s.txt' % (mocod_folder, moco_cov, subject_id + '_motion_params_' + raw_image_name[:-7]))
    
    # Calculate all 24 motion derivatives
    for i in os.listdir(moco_cov):
        original_par = os.path.join(moco_cov, i)
        pd.set_option('display.precision', 8)
        data = pd.read_csv(original_par, sep='  ', header=None, engine='python')
        data_sqrted = data ** 2
        data_diffed = data.diff(periods=1, axis=0)
        data_diffed = data_diffed.fillna(0)
        data_diffed_sqrt = data_diffed ** 2 
        data_concatted = pd.concat([data, data_sqrted, data_diffed, data_diffed_sqrt], axis=1)
        np.savetxt(original_par, data_concatted, delimiter='  ')
        
    return (mc_to_this, moco_cov, motion_corrected_epi)

def firstLevelReg(subject_id, raw_image_name, motion_corrected_epi, t1_image, output_folder):
    # Create a first level directory 
    t1_registered_folder = os.path.join(output_folder, 'step3_' + subject_id + '_t1_registered_epi')
    if not os.path.exists(t1_registered_folder):
        os.system('mkdir %s' % t1_registered_folder)    
    t1_registration_intermediates = os.path.join(output_folder, subject_id + '_t1_registered_intermediate')
    if not os.path.exists(t1_registration_intermediates):
        os.system('mkdir %s' % t1_registration_intermediates) 
        
    # get a single TR
    single_tr = os.path.join(t1_registration_intermediates, 'single_' + raw_image_name)
    os.system('fslroi %s %s 0 1' % (motion_corrected_epi, single_tr))
    
    # Perform the registration
    os.system('antsRegistrationSyN.sh -f %s -m %s -t r -o %s/t1RegisteredEpi' % (t1_image, single_tr, t1_registration_intermediates))    
    
    epi_to_t1_affine = os.path.join(t1_registration_intermediates, 't1RegisteredEpi0GenericAffine.mat')
    epi_to_t1_warped = os.path.join(t1_registration_intermediates, 't1RegisteredEpiWarped.nii.gz')    
    
    return (epi_to_t1_affine, epi_to_t1_warped)

def apply_warp(subject_id, motion_corrected_epi, template_path, output_folder, epi_to_t1_affine, t1_to_template_affine, t1_to_template_warp):
    warped_folder = os.path.join(output_folder, 'step4_' + subject_id + '_template_registered_epi')  
    if not os.path.exists(warped_folder):
        os.system('mkdir %s' % warped_folder)    
    
    warped_epi = os.path.join(warped_folder, 'templateWarped.nii.gz')
    transform_call = ('antsApplyTransforms --float --default-value 0 '
                      '-i %s -e 3 '
                      '-n Linear -o %s '
                      '-r %s '
                      '-t %s -t %s -t %s '
                      '-v 1' % (motion_corrected_epi, warped_epi, template_path,
                                t1_to_template_warp, t1_to_template_affine,
                                epi_to_t1_affine))    
    os.system(transform_call)    
    
    return warped_epi

def set_zero(data_path, template_path, output_path):
    data = nib.load(data_path)
    data_val = data.get_data()
    atlas = nib.load(template_path)
    atlas_data_val = atlas.get_data()
    zero_indexes = np.argwhere(atlas_data_val == 0)
    
    for index in zero_indexes:
        x = index[0]
        y = index[1]
        z = index[2]
        data_val[x, y, z] = 0
    
    nib.save(data, output_path)

def make_plot(subject_id, base_image, overlay, title, subtitle, filename, x, y, z, output_folder):
    
    # This function simply gets two MRI images as inputs and overlays them 
    #using different colors for each image. Used as a diagnostic method.
        
    fig, (ax1, ax2, ax3) = plt.subplots(1,3)
    fig.suptitle(title, fontsize=20)
    ax2.title.set_text(subtitle)
    
    epi_img = nib.load(base_image)
    epi_img_data = epi_img.get_fdata()
    ax1.imshow(epi_img_data[x,:,:], cmap="gray")
    ax2.imshow(epi_img_data[:,y,:], cmap="gray")
    ax3.imshow(epi_img_data[:,:,z], cmap="gray")
    ax1.axis('off')
    ax2.axis('off')
    ax3.axis('off')  
    
    if overlay != 'NA':
        epi_img = nib.load(overlay)
        epi_img_data = epi_img.get_fdata()
        ax1.imshow(epi_img_data[x,:,:], cmap="hot", alpha=0.4)
        ax2.imshow(epi_img_data[:,y,:], cmap="hot", alpha=0.4)
        ax3.imshow(epi_img_data[:,:,z], cmap="hot", alpha=0.4)
        ax1.axis('off')
        ax2.axis('off')
        ax3.axis('off')

    plt.savefig(os.path.join(output_folder, subject_id + '_' + filename))    
    
    return (output_folder)
    
def make_gif(image_folder, gif_name, output_folder):
    images = []
    for filename in os.listdir(image_folder):
        images.append(imageio.imread(os.path.join(image_folder, filename)))
        imageio.mimsave('/%s/%s.gif' % (output_folder, gif_name), images, duration=0.9)
        
###################### Define the Paths and parameters ###########################

# os.system('cat /proc/cpuinfo')

# Set paths and create some folders
flywheel_base ='/flywheel/v0/'
first_output_dir = '/firstOutput'
os.system('mkdir %s'%first_output_dir)
invivo_template = '/opt/invivoTemplate.nii.gz'
resampled_template_path = '/opt/2x2x2resampled_invivoTemplate.nii.gz'
final_output_dir = os.path.join(flywheel_base, 'output')
manifest_file = os.path.join(flywheel_base, 'manifest.json')
config_path = os.path.join(flywheel_base, 'config.json')

# Get the time series
fMRITimeSeries_folder = os.path.join(flywheel_base, 'input/fMRITimeSeries')
file_name = os.listdir(fMRITimeSeries_folder)[0]
fMRITimeSeries = os.path.join(fMRITimeSeries_folder, file_name)

# Unzip the structural zip
preprocessedStruct_folder = os.path.join(flywheel_base, 'input/StructZip')
preprocessedStruct = os.path.join(preprocessedStruct_folder, os.listdir(preprocessedStruct_folder)[0]) 
struct_folder = '/opt/struct'
os.system('mkdir %s' % struct_folder)
os.system('unzip -q %s -d %s' % (preprocessedStruct, struct_folder))

# Create the scout folder and get the scout images
scout_folder = '/opt/scout'
os.system('mkdir %s' % scout_folder)

fMRIScoutAP_folder = os.path.join(flywheel_base, 'input/fMRIScoutAP')
if os.path.exists(fMRIScoutAP_folder):
    fMRIScoutAP = os.path.join(fMRIScoutAP_folder, os.listdir(fMRIScoutAP_folder)[0])
    os.system('cp %s %s' % (fMRIScoutAP, scout_folder))

fMRIScoutPA_folder = os.path.join(flywheel_base, 'input/fMRIScoutPA')
if os.path.exists(fMRIScoutPA_folder):
    fMRIScoutPA = os.path.join(fMRIScoutPA_folder, os.listdir(fMRIScoutPA_folder)[0])
    os.system('cp %s %s' % (fMRIScoutPA, scout_folder))        
        
###################Parse Config Here############################

with open(config_path) as config_file:
    job_config = json.load(config_file)
config = job_config['config']

total_readout_time_AP = config['totalReadoutTimeAP']
total_readout_time_PA = config['totalReadoutTimePA']
saveIntermediateFiles = config['saveIntermediateFiles']
fMRIName = config['fMRIName']

# Get the subject id and set some more paths
with open ('%s' % os.path.join(struct_folder, 'subject_id.txt'), 'r') as idfile:
    subject_id = idfile.readlines()[0]
generic_affine = os.path.join(struct_folder, subject_id + '_reg_avgmprage2atlas', subject_id + '_0GenericAffine.mat')
path_to_warp = os.path.join(struct_folder, subject_id + '_reg_avgmprage2atlas', subject_id + '_1Warp.nii.gz')
path_to_averaged_t1 = os.path.join(struct_folder, subject_id + '_preprocessed_mprage', subject_id + '_averaged_mprages.nii.gz')

# If specified, add the fMRIName to subject id
if fMRIName != 'NA':
    subject_id = subject_id + '_' + fMRIName
        
################### Run Algorithm ###############################
# Calculate and apply topup if both AP and PA are specified
raw_image_name, top_up_folder, bias_corrected_epi = topup(subject_id, total_readout_time_AP, total_readout_time_PA, scout_folder, fMRITimeSeries, first_output_dir)

# Motion correction 
mc_to_this, moco_cov, motion_corrected_epi = moco(subject_id, raw_image_name, bias_corrected_epi, top_up_folder, first_output_dir)

# Calculate epi to t1
epi_to_t1_affine, epi_to_t1_warped = firstLevelReg(subject_id, raw_image_name, motion_corrected_epi, path_to_averaged_t1, first_output_dir)

# Apply warp
warped_epi = apply_warp(subject_id, motion_corrected_epi, resampled_template_path, first_output_dir, epi_to_t1_affine, generic_affine, path_to_warp)
                 
# Where there are zeros on the template, set zero to warped epi image
set_zero(warped_epi, resampled_template_path, warped_epi)

# Make an plot the invivo and warped EPI seperately
temporary_image = '/usr/tempim/'
os.system('mkdir %s' % temporary_image)
temporary_plot = '/usr/tempplt/'
temporary_plot2 = '/usr/tempplt2/'
os.system('mkdir %s' % temporary_plot)
os.system('mkdir %s' % temporary_plot2)
single_warped = os.path.join(temporary_image, 'singleEPI.nii.gz')
os.system('FSLDIR=/usr/lib/fsl/5.0;. /etc/fsl/5.0/fsl.sh;PATH=${FSLDIR}:${PATH};export FSLDIR PATH;/usr/lib/fsl/5.0/fslroi %s %s 0 1' % (warped_epi, single_warped))

make_plot(subject_id, path_to_averaged_t1, 'NA', subject_id + ' EPI_to_T1', 't1', subject_id + '_invivo.png', 26, 23, 26, temporary_plot)
make_plot(subject_id, epi_to_t1_warped, 'NA', subject_id + ' EPI_to_T1', 'epi', subject_id + '_invivo2.png', 26, 23, 26, temporary_plot)
make_gif(temporary_plot, 'epi_to_t1', first_output_dir)

make_plot(subject_id, resampled_template_path, 'NA', subject_id + ' EPI_2_Template', 'tempate', subject_id + '_final.png', 26, 23, 26, temporary_plot2)
make_plot(subject_id, single_warped, 'NA', subject_id + ' EPI_2_Template', 'warped epi', subject_id + '_final2.png', 26, 23, 26, temporary_plot2)
make_gif(temporary_plot2, 'epi_to_template', first_output_dir)
