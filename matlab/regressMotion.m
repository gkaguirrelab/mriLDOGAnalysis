function correctedFuncPath = regressMotion(epiPath, motionParamsPath, outputFolder, varargin)
% Pre-process the ldog func data to regress out the effects of motion
%
% Syntax:
%  correctedFuncPath = regressMotion(funcZipPath, motionParamsPath)
%
% Description
%   Loads a volumetric, 4D fMRI dataset and the motion parameter vectors
%   generated by the XXX routine. These vectors are treated as a regression
%   matrix and the effect of motion is removed from the data (preserving
%   signal mean). The motion-cleaned data is written back to disk.
%
%   Requires the Freesurfer MATLAB library to handle read/write operations.
%
% Inputs:
%   epiPath               - String. Path to .nii file that contains the
%                           fMRI data to be analyzed. This is the unzipped
%                           output of the ldogFunc.
%   motionParamsPath      - String. Path to a .txt file that contains the
%                           motion covariates.
%   outputFolder          - String. Output folder for the processed data.\   
%
% Optional key/value pairs:
%   regressGlobalSignal   - String. Regress globabl signal if true. Default
%                           false. 
%
% Outputs:
%   correctedFuncPath     - String. Full path to the uncompressed
%                           functional MRI data file that has undergone
%                           regression to remove the effects of motion.
%
%   convertToPercentChangeSignal    - Convert data to percentage change.
%                                     Default: False
%   
%   stimFile              - String. If stimulus files is supplied, regress
%                           out the effects from the data.
%
%   rawFmriData           - String. If a raw fmri data is supplied, outlier
%                           detection is performed.
%
%   voxelMADthreshold     - String. For the spike detection, first an
%                           outlier detection is performed on all voxels
%                           and number of outliers are counted. This
%                           threshold decides how many MADs a voxel should
%                           be above the mean to be counted as an outlier
%
%   meanMADthreshold      - String. 2nd part of spike detection is
%                           performed on the mean voxel image. This
%                           threshold decides how many MAD a TR should be
%                           above a threshold to be considered as an
%                           outlier.
%                           
% Examples:
%{
    epiPath = 'N292_photoFlicker_1_LplusS_run01_preprocessed__1.3.12.2.1107.5.2.32.35335.2019120511441319299753175.0.0.0.nii.gz';
    motionParamsPath = 'N292_photoFlicker_1_LplusS_run01_motion_params_1.3.12.2.1107.5.2.32.35335.2019120511441319299753175.0.0.0.nii.gz.txt';
    stimFile = 'blockedStimulus_1x144_On=1.mat';
    correctedFuncPath = regressMotion(epiPath, motionParamsPath,'','stimFile',stimFile);
%}

%% Parse inputs
p = inputParser; p.KeepUnmatched = false;

% Required
p.addRequired('epiPath',@isstr);
p.addRequired('motionParamsPath',@isstr);
p.addRequired('outputFolder',@isstr);

% Optional
p.addParameter('regressGlobalSignal', "false",@isstr)
p.addParameter('convertToPercentChangeSignal', "false",@isstr)
p.addParameter('stimFile', "Na" ,@isstr)
p.addParameter('rawFmriData', "Na", @isstr)
p.addParameter('voxelMADthresh', "5", @isstr)
p.addParameter('meanMADthresh', "25", @isstr)

% Parse
p.parse(epiPath, motionParamsPath, outputFolder, varargin{:})

% Extract the file name and extension from the full path 
[~,name,ext] = fileparts(epiPath);
acqusitionName = strcat(name, ext);

% Load the data
thisAcqData = MRIread(epiPath);

% Get the original shape of the data for later reshaping
originalShape = size(thisAcqData.vol);

% Get the volume
data = thisAcqData.vol;
    
% Reshape into a matrix
data = single(data);
data = reshape(data, [size(data,1)*size(data,2)*size(data,3), size(data,4)]);
data(isnan(data)) = 0;

% Load and format the motion covariates
X = readmatrix(motionParamsPath);

% Check that the motion covariates and data match
if size(X,1) ~= size(data,2)
    error('regressMotion:mismatchRegressors','The data and motion parameters have different temporal lengths');
end

% regressGlobalSignal if set
if strcmp(p.Results.regressGlobalSignal,"true")

    % Intra-cortical voxels will never have a zero value in their time
    % series
    idx = ~any(data'==0)';

    % Obtain the mean intra-cortical signal, and add it to X
    X(:,end+1) = mean(data(idx,:));

end

% Mean center the elements of the X matrix, and standardize
for ii=1:size(X,2)
    X(:,ii) = X(:,ii) - mean(X(:,ii));
    X(:,ii) = X(:,ii) / std(X(:,ii));
end

% If a stimulusVector has been supplied, load this and partial this effect
% out of the X matrix
if ~strcmp(p.Results.stimFile,'Na')
    % Load the stimulus
    load(p.Results.stimFile,'stimulus');
    % We want a vector, not a cell
    if iscell(stimulus)
        stimulus = stimulus{1};
    end
    % Check that we were passed a vector
    if size(stimulus,1) ~= 1
        error('regressMotion:multiDimensionalStimulus','The stimulus must be a one dimensional vector');
    end
    % Check that the stiumulus matches the data
    if size(data,2) ~= length(stimulus)
        error('regressMotion:mismatchStimulus','The data and the stimulus vector have different temporal lengths');
    end
    % Prepare the stimulus vector for regression
    stimulus = (stimulus - mean(stimulus))';
    % Regress the stimulus out of each element of the X matrix
    for ii = 1:size(X,2)
        b=stimulus\X(:,ii);
        X(:,ii) = X(:,ii) - b*stimulus;
    end
end

% Perform a dimensionality reduction on the X matix to keep those pca
% coefficients that explain at least 5% of the variance
[coeff,~,~,~,explained] = pca(X');
X=coeff(:,1:find(explained<5,1)-1);

% If a raw image is supplied, do spike regression. This includes
% first performin linear detrending on the data and counting the outlier 
% voxels in each TR. Outliers are 5 MAD above the median value. Then the 
% resulting vector is again gone thorugh outlier detection and values above
% 25 MAD are considered spikes.
if ~strcmp(p.Results.rawFmriData, 'Na')
    % Read and reshape
    rawMRI = MRIread(p.Results.rawFmriData);
    rawMRIVol = rawMRI.vol; 
    rawMRISize = size(rawMRIVol);
    rawMRIReshaped = reshape(rawMRIVol, [rawMRISize(1)*rawMRISize(2)*rawMRISize(3), rawMRISize(4)]);
    rawMRIReshaped = detrend(rawMRIReshaped',1)';
    
    % Find the outliers in each voxel across time
    outliers = isoutlier(rawMRIReshaped, 2, 'thresholdFactor', str2num(p.Results.voxelMADthresh));
    
    % Find number of outliers in each TR
    outlierCount = sum(outliers);
    
    % Threshold this vector again with 10 MAD to detect spikes
    spikesConfoundAll = isoutlier(outlierCount, 'thresholdFactor', str2num(p.Results.meanMADthresh));
    
    % Now make sure each spike has its own column
    nonZer = find(spikesConfoundAll);
    spikesConfoundMat = zeros(length(nonZer), length(spikesConfoundAll));
    for ii = 1:length(nonZer)
        spikesConfoundMat(ii,nonZer(ii)) = 1;
    end
    spikesConfoundMat = spikesConfoundMat';
    
    % Make an axial plot of the TRs which have spikes 
    plot_folder = fullfile(outputFolder, 'spikeSlices');
    mkdir(plot_folder)
    spikeIndx = find(spikesConfoundAll);
    fig = figure('visible', 'off');
    plot(outlierCount)
    xlabel('TR')
    ylabel('number of spiky voxels')
    title('Spike detection')
    saveas(fig, fullfile(plot_folder, 'spikeDetection.png'))
    fig = figure('visible', 'off');
    plot(spikesConfoundAll)
    xlabel('TR')
    ylabel('Confounds')
    title('Detected confound locations')
    saveas(fig, fullfile(plot_folder, 'confound.png'))   
    for ii = 1:length(spikeIndx)
        subfolder = fullfile(plot_folder, ['TR_' num2str(spikeIndx(ii))]);
        mkdir(subfolder)
        spikeVolume = rawMRIVol(:,:,:,spikeIndx(ii));
        for vv = 1:rawMRISize(3)
            fig = figure('visible', 'off');
            colormap(gray)
            imagesc(spikeVolume(:,:,vv))
            saveas(fig, fullfile(subfolder, [num2str(vv) '.png']))
        end
    end 
    
    % Mean center and standardize the vector and add it to the X
    for ii=1:size(spikesConfoundMat,2)
        spikesConfoundMat(:,ii) = spikesConfoundMat(:,ii) - mean(spikesConfoundMat(:,ii));
        spikesConfoundMat(:,ii) = spikesConfoundMat(:,ii) / std(spikesConfoundMat(:,ii));
    end    
    X = [X spikesConfoundMat];
end

% Store the warning state
warningState = warning;

% Silence warnings.
warning('off','MATLAB:rankDeficientMatrix');

% Loop through the voxels and regress out the motion component
for vv = 1:size(data,1)
    datats = data(vv,:)';
    if all(datats==0)
        continue
    end
    meants = mean(datats);
    beta = X\datats;
    cleants = datats - X*beta + meants;

    % If asked to do so, convert the data to % change units
    if strcmp(p.Results.convertToPercentChangeSignal,"true")
        cleants = 100.* ((cleants - meants)./meants)+100;
    end
    
    % Store the cleaned vector
    data(vv,:) = cleants';
    
end

% Restore the warning state.
warning(warningState);

% Put the cleaned data back into the acquisition and reshape to 4D
thisAcqData.vol = data;
thisAcqData.vol = reshape(thisAcqData.vol, originalShape);

% Set the save name
newName = strrep(acqusitionName, '_warped_epi_','_preprocessed_');

% Save the motion corrected fMRI data
correctedFuncPath = fullfile(outputFolder,newName);
MRIwrite(thisAcqData,correctedFuncPath);

end % Main function
